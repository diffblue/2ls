2LS version 0.3.4 (based on CBMC 5.4)
Parsing main.c
Converting
Type-checking main
file main.c line 53 function check_seq_next: function `assert' is not declared
Generating GOTO Program
Adding CPROVER library
Generic Property Instrumentation
Function Pointer Removal
Performing full inlining
Using heap domain
Computing SSA of _start
Simplifying
(E) $guard#0 == TRUE

(E) __CPROVER_dead_object#2 == NULL

(E) __CPROVER_deallocated#3 == NULL

(E) __CPROVER_malloc_is_new_array#4 == FALSE

(E) __CPROVER_malloc_object#5 == NULL

(E) __CPROVER_malloc_size#6 == 0ul

(E) __CPROVER_memory_leak#7 == NULL

(E) __CPROVER_next_thread_id#8 == 0ul

(E) __CPROVER_pipe_count#9 == 0u

(E) __CPROVER_rounding_mode#10 == 0

(E) __CPROVER_thread_id#11 == 0ul

(E) __CPROVER_threads_exited#12 == ARRAY_OF(FALSE)

(E) p1#16 == nondet_symbol(ssa::nondet16.1)

(E) p2#18 == nondet_symbol(ssa::nondet18.1)

(E) list#20 == nondet_symbol(ssa::nondet20.1)

(E) pp1#23 == nondet_symbol(ssa::nondet23.1)

(E) pp1#24 == &p1

(E) pp2#26 == nondet_symbol(ssa::nondet26.1)

(E) pp2#27 == &p2

(E) p2#28 == ((struct node *)NULL)

(E) i#30 == nondet_symbol(ssa::nondet30.1)

(E) i#31 == 0

(E) __CPROVER_deallocated#phi32 == ($guard#ls101 ? __CPROVER_deallocated#lb101 : __CPROVER_deallocated#3)
(E) __CPROVER_malloc_object#phi32 == ($guard#ls101 ? __CPROVER_malloc_object#lb101 : __CPROVER_malloc_object#5)
(E) __CPROVER_malloc_size#phi32 == ($guard#ls101 ? __CPROVER_malloc_size#lb101 : __CPROVER_malloc_size#6)
(E) __CPROVER_malloc_is_new_array#phi32 == ($guard#ls101 ? __CPROVER_malloc_is_new_array#lb101 : __CPROVER_malloc_is_new_array#4)
(E) __CPROVER_memory_leak#phi32 == ($guard#ls101 ? __CPROVER_memory_leak#lb101 : __CPROVER_memory_leak#7)
(E) i#phi32 == ($guard#ls101 ? i#lb101 : i#31)
(E) p2#phi32 == ($guard#ls101 ? p2#lb101 : p2#28)
(E) dynamic_object$0.next#phi32 == ($guard#ls101 ? dynamic_object$0.next#lb101 : dynamic_object$0.next)
(E) $cond#32 == i#phi32 >= 2
(E) $guard#32 == $guard#0

(E) $guard#33 == (!$cond#32 && $guard#32)

(E) ppnode#35 == nondet_symbol(ssa::nondet35.1)

(E) ppnode#36 == pp2#27

(E) node#38 == nondet_symbol(ssa::nondet38.1)

(E) ptr#41 == nondet_symbol(ssa::nondet41.1)

(E) return_value_malloc$1#43 == nondet_symbol(ssa::nondet43.1)

(E) malloc_size#46 == nondet_symbol(ssa::nondet46.1)

(E) malloc_size#47 == sizeof(struct node) /*8ul*/ 

(E) malloc_res#50 == nondet_symbol(ssa::nondet50.1)

(E) malloc_value$1#52 == nondet_symbol(ssa::nondet52.1)

(E) malloc_value$1#53 == (void *)&dynamic_object$0

(E) malloc_res#54 == malloc_value$1#53

(E) __CPROVER_deallocated#56 == (malloc_res#54 == __CPROVER_deallocated#phi32 ? NULL : __CPROVER_deallocated#phi32)

(E) record_malloc#58 == nondet_symbol(ssa::nondet58.1)

(E) __CPROVER_malloc_object#59 == (record_malloc#58 ? malloc_res#54 : __CPROVER_malloc_object#phi32)

(E) __CPROVER_malloc_size#60 == (record_malloc#58 ? malloc_size#47 : __CPROVER_malloc_size#phi32)

(E) __CPROVER_malloc_is_new_array#61 == (!record_malloc#58 && __CPROVER_malloc_is_new_array#phi32)

(E) record_may_leak#63 == nondet_symbol(ssa::nondet63.1)

(E) __CPROVER_memory_leak#64 == (record_may_leak#63 ? malloc_res#54 : __CPROVER_memory_leak#phi32)

(E) malloc#return_value#65 == malloc_res#54

(E) $cond#70 == TRUE

(E) $guard#71 == FALSE

(E) $guard#75 == ($cond#70 && $guard#33 || $guard#71)

(E) return_value_malloc$1#77 == malloc#return_value#65

(E) ptr#79 == (struct node *)return_value_malloc$1#77

(E) $cond#81 == !(ptr#79 == ((struct node *)NULL))

(E) $guard#82 == (!$cond#81 && $guard#75)

(E) $cond#83 == FALSE

(E) $guard#84 == ($cond#83 && $guard#82)

(E) dynamic_object$0.next#85 == ((struct node *)NULL)
(E) $guard#85 == ($cond#81 && $guard#75 || $guard#84)

(E) alloc_node#return_value#86 == ptr#79

(E) $cond#89 == TRUE

(E) $guard#90 == FALSE

(E) $guard#92 == ($cond#89 && $guard#85 || $guard#90)

(E) node#93 == alloc_node#return_value#86

(E) dynamic_object$0.next#95 == (ppnode#36 == &p2 ? p2#phi32 : deref#95)

(E) p2#96 == node#93

(E) i#100 == 1 + i#phi32

(E) $cond#101 == TRUE

(E) $guard#102 == ($cond#32 && $guard#32)

(E) p1#103 == (pp2#27 == &p2 ? p2#phi32 : deref#103)

(E) i#105 == nondet_symbol(ssa::nondet105.1)

(E) i#106 == 0

(E) __CPROVER_deallocated#phi107 == ($guard#ls176 ? __CPROVER_deallocated#lb176 : __CPROVER_deallocated#phi32)
(E) __CPROVER_malloc_object#phi107 == ($guard#ls176 ? __CPROVER_malloc_object#lb176 : __CPROVER_malloc_object#phi32)
(E) __CPROVER_malloc_size#phi107 == ($guard#ls176 ? __CPROVER_malloc_size#lb176 : __CPROVER_malloc_size#phi32)
(E) __CPROVER_malloc_is_new_array#phi107 == ($guard#ls176 ? __CPROVER_malloc_is_new_array#lb176 : __CPROVER_malloc_is_new_array#phi32)
(E) __CPROVER_memory_leak#phi107 == ($guard#ls176 ? __CPROVER_memory_leak#lb176 : __CPROVER_memory_leak#phi32)
(E) i#phi107 == ($guard#ls176 ? i#lb176 : i#106)
(E) p1#phi107 == ($guard#ls176 ? p1#lb176 : p1#103)
(E) dynamic_object$1.next#phi107 == ($guard#ls176 ? dynamic_object$1.next#lb176 : dynamic_object$1.next)
(E) $cond#107 == i#phi107 >= 2
(E) $guard#107 == $guard#102

(E) $guard#108 == (!$cond#107 && $guard#107)

(E) ppnode#110 == nondet_symbol(ssa::nondet110.1)

(E) ppnode#111 == pp1#24

(E) node#113 == nondet_symbol(ssa::nondet113.1)

(E) ptr#116 == nondet_symbol(ssa::nondet116.1)

(E) return_value_malloc$1#118 == nondet_symbol(ssa::nondet118.1)

(E) malloc_size#121 == nondet_symbol(ssa::nondet121.1)

(E) malloc_size#122 == sizeof(struct node) /*8ul*/ 

(E) malloc_res#125 == nondet_symbol(ssa::nondet125.1)

(E) malloc_value$1#127 == nondet_symbol(ssa::nondet127.1)

(E) malloc_value$1#128 == (void *)&dynamic_object$1

(E) malloc_res#129 == malloc_value$1#128

(E) __CPROVER_deallocated#131 == (malloc_res#129 == __CPROVER_deallocated#phi107 ? NULL : __CPROVER_deallocated#phi107)

(E) record_malloc#133 == nondet_symbol(ssa::nondet133.1)

(E) __CPROVER_malloc_object#134 == (record_malloc#133 ? malloc_res#129 : __CPROVER_malloc_object#phi107)

(E) __CPROVER_malloc_size#135 == (record_malloc#133 ? malloc_size#122 : __CPROVER_malloc_size#phi107)

(E) __CPROVER_malloc_is_new_array#136 == (!record_malloc#133 && __CPROVER_malloc_is_new_array#phi107)

(E) record_may_leak#138 == nondet_symbol(ssa::nondet138.1)

(E) __CPROVER_memory_leak#139 == (record_may_leak#138 ? malloc_res#129 : __CPROVER_memory_leak#phi107)

(E) malloc#return_value#140 == malloc_res#129

(E) $cond#145 == TRUE

(E) $guard#146 == FALSE

(E) $guard#150 == ($cond#145 && $guard#108 || $guard#146)

(E) return_value_malloc$1#152 == malloc#return_value#140

(E) ptr#154 == (struct node *)return_value_malloc$1#152

(E) $cond#156 == !(ptr#154 == ((struct node *)NULL))

(E) $guard#157 == (!$cond#156 && $guard#150)

(E) $cond#158 == FALSE

(E) $guard#159 == ($cond#158 && $guard#157)

(E) dynamic_object$1.next#160 == ((struct node *)NULL)
(E) $guard#160 == ($cond#156 && $guard#150 || $guard#159)

(E) alloc_node#return_value#161 == ptr#154

(E) $cond#164 == TRUE

(E) $guard#165 == FALSE

(E) $guard#167 == ($cond#164 && $guard#160 || $guard#165)

(E) node#168 == alloc_node#return_value#161

(E) dynamic_object$1.next#170 == (ppnode#111 == &p1 ? p1#phi107 : deref#170)

(E) p1#171 == node#168

(E) i#175 == 1 + i#phi107

(E) $cond#176 == TRUE

(E) $guard#177 == ($cond#107 && $guard#107)

(E) list#179 == nondet_symbol(ssa::nondet179.1)

(E) list#180 == (pp1#24 == &p1 ? p1#phi107 : deref#180)

(E) i#182 == nondet_symbol(ssa::nondet182.1)

(E) i#183 == 0

(E) __CPROVER_deallocated#phi184 == ($guard#ls253 ? __CPROVER_deallocated#lb253 : __CPROVER_deallocated#phi107)
(E) __CPROVER_malloc_object#phi184 == ($guard#ls253 ? __CPROVER_malloc_object#lb253 : __CPROVER_malloc_object#phi107)
(E) __CPROVER_malloc_size#phi184 == ($guard#ls253 ? __CPROVER_malloc_size#lb253 : __CPROVER_malloc_size#phi107)
(E) __CPROVER_malloc_is_new_array#phi184 == ($guard#ls253 ? __CPROVER_malloc_is_new_array#lb253 : __CPROVER_malloc_is_new_array#phi107)
(E) __CPROVER_memory_leak#phi184 == ($guard#ls253 ? __CPROVER_memory_leak#lb253 : __CPROVER_memory_leak#phi107)
(E) list#phi184 == ($guard#ls253 ? list#lb253 : list#180)
(E) i#phi184 == ($guard#ls253 ? i#lb253 : i#183)
(E) dynamic_object$2.next#phi184 == ($guard#ls253 ? dynamic_object$2.next#lb253 : dynamic_object$2.next)
(E) $cond#184 == i#phi184 >= 2
(E) $guard#184 == $guard#177

(E) $guard#185 == (!$cond#184 && $guard#184)

(E) ppnode#187 == nondet_symbol(ssa::nondet187.1)

(E) ppnode#188 == &list

(E) node#190 == nondet_symbol(ssa::nondet190.1)

(E) ptr#193 == nondet_symbol(ssa::nondet193.1)

(E) return_value_malloc$1#195 == nondet_symbol(ssa::nondet195.1)

(E) malloc_size#198 == nondet_symbol(ssa::nondet198.1)

(E) malloc_size#199 == sizeof(struct node) /*8ul*/ 

(E) malloc_res#202 == nondet_symbol(ssa::nondet202.1)

(E) malloc_value$1#204 == nondet_symbol(ssa::nondet204.1)

(E) malloc_value$1#205 == (void *)&dynamic_object$2

(E) malloc_res#206 == malloc_value$1#205

(E) __CPROVER_deallocated#208 == (malloc_res#206 == __CPROVER_deallocated#phi184 ? NULL : __CPROVER_deallocated#phi184)

(E) record_malloc#210 == nondet_symbol(ssa::nondet210.1)

(E) __CPROVER_malloc_object#211 == (record_malloc#210 ? malloc_res#206 : __CPROVER_malloc_object#phi184)

(E) __CPROVER_malloc_size#212 == (record_malloc#210 ? malloc_size#199 : __CPROVER_malloc_size#phi184)

(E) __CPROVER_malloc_is_new_array#213 == (!record_malloc#210 && __CPROVER_malloc_is_new_array#phi184)

(E) record_may_leak#215 == nondet_symbol(ssa::nondet215.1)

(E) __CPROVER_memory_leak#216 == (record_may_leak#215 ? malloc_res#206 : __CPROVER_memory_leak#phi184)

(E) malloc#return_value#217 == malloc_res#206

(E) $cond#222 == TRUE

(E) $guard#223 == FALSE

(E) $guard#227 == ($cond#222 && $guard#185 || $guard#223)

(E) return_value_malloc$1#229 == malloc#return_value#217

(E) ptr#231 == (struct node *)return_value_malloc$1#229

(E) $cond#233 == !(ptr#231 == ((struct node *)NULL))

(E) $guard#234 == (!$cond#233 && $guard#227)

(E) $cond#235 == FALSE

(E) $guard#236 == ($cond#235 && $guard#234)

(E) dynamic_object$2.next#237 == ((struct node *)NULL)
(E) $guard#237 == ($cond#233 && $guard#227 || $guard#236)

(E) alloc_node#return_value#238 == ptr#231

(E) $cond#241 == TRUE

(E) $guard#242 == FALSE

(E) $guard#244 == ($cond#241 && $guard#237 || $guard#242)

(E) node#245 == alloc_node#return_value#238

(E) dynamic_object$2.next#247 == (ppnode#188 == &list ? list#phi184 : deref#247)

(E) list#248 == node#245

(E) i#252 == 1 + i#phi184

(E) $cond#253 == TRUE

(E) $guard#254 == ($cond#184 && $guard#184)

(E) create_sll#return_value#255 == list#phi184

(E) $cond#257 == TRUE

(E) $guard#258 == FALSE

(E) $guard#259 == ($cond#257 && $guard#254 || $guard#258)

(E) list#262 == create_sll#return_value#255

(E) beg#266 == nondet_symbol(ssa::nondet266.1)

(E) beg#267 == list#262

(E) end#269 == nondet_symbol(ssa::nondet269.1)

(E) end#270 == p1#phi107

(A) !(beg#267 == ((struct node *)NULL)) || !$guard#259

(A) !(end#270 == ((struct node *)NULL)) || !$guard#259

(E) beg#273 == (beg#267 == &dynamic_object$2 ? dynamic_object$2.next#phi184 : (beg#267 == &dynamic_object$1 ? dynamic_object$1.next#phi107 : (beg#267 == &dynamic_object$0 ? dynamic_object$0.next#phi32 : deref#273.next)))

(E) beg#phi274 == ($guard#ls277 ? beg#lb277 : beg#273)
(E) $cond#274 == (end#270 == beg#phi274)
(E) $guard#274 == $guard#259

(E) $guard#275 == (!$cond#274 && $guard#274)
(A) !(beg#phi274 == ((struct node *)NULL)) || !$guard#275

(E) beg#276 == (beg#phi274 == &dynamic_object$2 ? dynamic_object$2.next#phi184 : (beg#phi274 == &dynamic_object$1 ? dynamic_object$1.next#phi107 : (beg#phi274 == &dynamic_object$0 ? dynamic_object$0.next#phi32 : deref#276.next)))

(E) $cond#277 == TRUE

(E) $guard#278 == ($cond#274 && $guard#274)

(E) beg#283 == nondet_symbol(ssa::nondet283.1)

(E) beg#284 == p1#phi107

(E) end#286 == nondet_symbol(ssa::nondet286.1)

(E) end#287 == p2#phi32

(A) !(beg#284 == ((struct node *)NULL)) || !$guard#278

(A) !(end#287 == ((struct node *)NULL)) || !$guard#278

(E) beg#290 == (beg#284 == &dynamic_object$1 ? dynamic_object$1.next#phi107 : (beg#284 == &dynamic_object$0 ? dynamic_object$0.next#phi32 : deref#290.next))

(E) beg#phi291 == ($guard#ls294 ? beg#lb294 : beg#290)
(E) $cond#291 == (end#287 == beg#phi291)
(E) $guard#291 == $guard#278

(E) $guard#292 == (!$cond#291 && $guard#291)
(A) !(beg#phi291 == ((struct node *)NULL)) || !$guard#292

(E) beg#293 == (beg#phi291 == &dynamic_object$1 ? dynamic_object$1.next#phi107 : (beg#phi291 == &dynamic_object$0 ? dynamic_object$0.next#phi32 : deref#293.next))

(E) $cond#294 == TRUE

(E) $guard#295 == ($cond#291 && $guard#291)



Summarizing function _start
Analyzing function _start
Computing summary
Template: 
(LOOP) [ $guard#32 && $guard#ls101 | $guard#92 && $cond#101 | $guard#92 && $cond#101 ] ===> 
      ?path(p2#lb101, DESTINATIONS)
(LOOP) [ $guard#32 && $guard#ls101 | $guard#92 && $cond#101 | $guard#92 && $cond#101 ] ===> 
      ?path(dynamic_object$0.next#lb101, DESTINATIONS)
(LOOP) [ $guard#107 && $guard#ls176 | $guard#167 && $cond#176 | $guard#167 && $cond#176 ] ===> 
      ?path(p1#lb176, DESTINATIONS)
(LOOP) [ $guard#107 && $guard#ls176 | $guard#167 && $cond#176 | $guard#167 && $cond#176 ] ===> 
      ?path(dynamic_object$1.next#lb176, DESTINATIONS)
(LOOP) [ $guard#184 && $guard#ls253 | $guard#244 && $cond#253 | $guard#244 && $cond#253 ] ===> 
      ?path(list#lb253, DESTINATIONS)
(LOOP) [ $guard#184 && $guard#ls253 | $guard#244 && $cond#253 | $guard#244 && $cond#253 ] ===> 
      ?path(dynamic_object$2.next#lb253, DESTINATIONS)
(LOOP) [ $guard#274 && $guard#ls277 | $guard#275 && $cond#277 | $guard#275 && $cond#277 ] ===> 
      ?path(beg#lb277, DESTINATIONS)
(LOOP) [ $guard#291 && $guard#ls294 | $guard#292 && $cond#294 | $guard#292 && $cond#294 ] ===> 
      ?path(beg#lb294, DESTINATIONS)

updating row: 0
add all paths: dynamic_object$0.next#lb101, through: dynamic_object$0
add points to: dynamic_object$0
updating row: 1
add destination: ((struct node *)NULL)
recursively updating row: 0
add all paths: dynamic_object$0.next#lb101, through: dynamic_object$0
updating row: 2
add all paths: dynamic_object$1.next#lb176, through: dynamic_object$1
add points to: dynamic_object$1
updating row: 3
add all paths: dynamic_object$0.next#lb101, through: dynamic_object$0
add points to: dynamic_object$0
recursively updating row: 2
add all paths: dynamic_object$1.next#lb176, through: dynamic_object$1
updating row: 3
add all paths: dynamic_object$1.next#lb176, through: dynamic_object$1
add points to: dynamic_object$1
recursively updating row: 2
add all paths: dynamic_object$1.next#lb176, through: dynamic_object$1
recursively updating row: 3
add all paths: dynamic_object$1.next#lb176, through: dynamic_object$1
updating row: 4
add all paths: dynamic_object$2.next#lb253, through: dynamic_object$2
add points to: dynamic_object$2
updating row: 5
add all paths: dynamic_object$1.next#lb176, through: dynamic_object$1
add points to: dynamic_object$1
recursively updating row: 4
add all paths: dynamic_object$2.next#lb253, through: dynamic_object$2
updating row: 5
add all paths: dynamic_object$2.next#lb253, through: dynamic_object$2
add points to: dynamic_object$2
recursively updating row: 4
add all paths: dynamic_object$2.next#lb253, through: dynamic_object$2
recursively updating row: 5
add all paths: dynamic_object$2.next#lb253, through: dynamic_object$2
updating row: 7
add all paths: dynamic_object$1.next#lb176, through: dynamic_object$1
add points to: dynamic_object$1
updating row: 7
add all paths: dynamic_object$0.next#lb101, through: dynamic_object$0
add points to: dynamic_object$0
updating row: 6
add all paths: dynamic_object$2.next#lb253, through: dynamic_object$2
add points to: dynamic_object$2
updating row: 6
add all paths: dynamic_object$1.next#lb176, through: dynamic_object$1
add points to: dynamic_object$1
updating row: 1
add all paths: dynamic_object$0.next#lb101, through: dynamic_object$0
add points to: dynamic_object$0
recursively updating row: 0
add all paths: dynamic_object$0.next#lb101, through: dynamic_object$0
recursively updating row: 1
add all paths: dynamic_object$0.next#lb101, through: dynamic_object$0
recursively updating row: 3
add all paths: dynamic_object$0.next#lb101, through: dynamic_object$0
recursively updating row: 7
add all paths: dynamic_object$0.next#lb101, through: dynamic_object$0

Summary for function _start
params: 
globals_in: __CPROVER_threads_exited __CPROVER_malloc_is_new_array __CPROVER_dead_object __CPROVER_deallocated __CPROVER_malloc_object __CPROVER_memory_leak ppnode'obj beg'obj.next end'obj.next pp1'obj pp2'obj __CPROVER_rounding_mode __CPROVER_pipe_count __CPROVER_malloc_size __CPROVER_next_thread_id __CPROVER_thread_id 
globals_out: __CPROVER_threads_exited#12 __CPROVER_malloc_is_new_array#phi184 __CPROVER_dead_object#2 __CPROVER_deallocated#phi184 __CPROVER_malloc_object#phi184 __CPROVER_memory_leak#phi184 ppnode'obj beg'obj.next end'obj.next pp1'obj pp2'obj __CPROVER_rounding_mode#10 __CPROVER_pipe_count#9 __CPROVER_malloc_size#phi184 __CPROVER_next_thread_id#8 __CPROVER_thread_id#11 
forward precondition: TRUE
forward transformer: TRUE
forward invariant: ($guard#32 && $guard#ls101 ==> p2#lb101 == &dynamic_object$0 && (dynamic_object$0.next#lb101 == ((struct node *)NULL) || dynamic_object$0.next#lb101 == &dynamic_object$0)) && ($guard#32 && $guard#ls101 ==> dynamic_object$0.next#lb101 == ((struct node *)NULL) || dynamic_object$0.next#lb101 == &dynamic_object$0 && (dynamic_object$0.next#lb101 == ((struct node *)NULL) || dynamic_object$0.next#lb101 == &dynamic_object$0)) && ($guard#107 && $guard#ls176 ==> p1#lb176 == &dynamic_object$1 && (dynamic_object$1.next#lb176 == ((struct node *)NULL) || dynamic_object$1.next#lb176 == &dynamic_object$0 || dynamic_object$1.next#lb176 == &dynamic_object$1)) && ($guard#107 && $guard#ls176 ==> dynamic_object$1.next#lb176 == &dynamic_object$0 && (dynamic_object$0.next#lb101 == ((struct node *)NULL) || dynamic_object$0.next#lb101 == &dynamic_object$0 || dynamic_object$0.next#lb101 == &dynamic_object$1) || dynamic_object$1.next#lb176 == &dynamic_object$1 && (dynamic_object$1.next#lb176 == ((struct node *)NULL) || dynamic_object$1.next#lb176 == &dynamic_object$0 || dynamic_object$1.next#lb176 == &dynamic_object$1)) && ($guard#184 && $guard#ls253 ==> list#lb253 == &dynamic_object$2 && (dynamic_object$2.next#lb253 == ((struct node *)NULL) || dynamic_object$2.next#lb253 == &dynamic_object$0 || dynamic_object$2.next#lb253 == &dynamic_object$1 || dynamic_object$2.next#lb253 == &dynamic_object$2)) && ($guard#184 && $guard#ls253 ==> dynamic_object$2.next#lb253 == &dynamic_object$1 && (dynamic_object$1.next#lb176 == ((struct node *)NULL) || dynamic_object$1.next#lb176 == &dynamic_object$0 || dynamic_object$1.next#lb176 == &dynamic_object$1 || dynamic_object$1.next#lb176 == &dynamic_object$2) || dynamic_object$2.next#lb253 == &dynamic_object$2 && (dynamic_object$2.next#lb253 == ((struct node *)NULL) || dynamic_object$2.next#lb253 == &dynamic_object$0 || dynamic_object$2.next#lb253 == &dynamic_object$1 || dynamic_object$2.next#lb253 == &dynamic_object$2)) && ($guard#274 && $guard#ls277 ==> beg#lb277 == &dynamic_object$1 && (dynamic_object$1.next#lb176 == ((struct node *)NULL) || dynamic_object$1.next#lb176 == &dynamic_object$0 || dynamic_object$1.next#lb176 == &dynamic_object$1 || dynamic_object$1.next#lb176 == &dynamic_object$2) || beg#lb277 == &dynamic_object$2 && (dynamic_object$2.next#lb253 == ((struct node *)NULL) || dynamic_object$2.next#lb253 == &dynamic_object$0 || dynamic_object$2.next#lb253 == &dynamic_object$1 || dynamic_object$2.next#lb253 == &dynamic_object$2)) && ($guard#291 && $guard#ls294 ==> beg#lb294 == &dynamic_object$0 && (dynamic_object$0.next#lb101 == ((struct node *)NULL) || dynamic_object$0.next#lb101 == &dynamic_object$0 || dynamic_object$0.next#lb101 == &dynamic_object$1) || beg#lb294 == &dynamic_object$1 && (dynamic_object$1.next#lb176 == ((struct node *)NULL) || dynamic_object$1.next#lb176 == &dynamic_object$0 || dynamic_object$1.next#lb176 == &dynamic_object$1))
backward precondition: not computed
backward postcondition: not computed
backward transformer: not computed
backward invariant: not computed
termination argument: not computed
terminates: unknown

Checking properties of _start
*** 0 
(E) $guard#0 == TRUE

*** 2 file <built-in-additions> line 39
(E) __CPROVER_dead_object#2 == NULL

*** 3 file <built-in-additions> line 38
(E) __CPROVER_deallocated#3 == NULL

*** 4 file <built-in-additions> line 42
(E) __CPROVER_malloc_is_new_array#4 == FALSE

*** 5 file <built-in-additions> line 40
(E) __CPROVER_malloc_object#5 == NULL

*** 6 file <built-in-additions> line 41
(E) __CPROVER_malloc_size#6 == 0ul

*** 7 file <built-in-additions> line 43
(E) __CPROVER_memory_leak#7 == NULL

*** 8 file <built-in-additions> line 31
(E) __CPROVER_next_thread_id#8 == 0ul

*** 9 file <built-in-additions> line 87
(E) __CPROVER_pipe_count#9 == 0u

*** 10 file <built-in-additions> line 65
(E) __CPROVER_rounding_mode#10 == 0

*** 11 file <built-in-additions> line 29
(E) __CPROVER_thread_id#11 == 0ul

*** 12 file <built-in-additions> line 30
(E) __CPROVER_threads_exited#12 == ARRAY_OF(FALSE)

*** 16 file main.c line 62 function main
(E) p1#16 == nondet_symbol(ssa::nondet16.1)

*** 18 file main.c line 62 function main
(E) p2#18 == nondet_symbol(ssa::nondet18.1)

*** 20 file main.c line 64 function main
(E) list#20 == nondet_symbol(ssa::nondet20.1)

*** 23 file main.c line 64 function main
(E) pp1#23 == nondet_symbol(ssa::nondet23.1)

*** 24 file main.c line 64 function main
(E) pp1#24 == &p1

*** 26 file main.c line 64 function main
(E) pp2#26 == nondet_symbol(ssa::nondet26.1)

*** 27 file main.c line 64 function main
(E) pp2#27 == &p2

*** 28 file main.c line 28 function create_sll
(E) p2#28 == ((struct node *)NULL)

*** 30 file main.c line 30 function create_sll
(E) i#30 == nondet_symbol(ssa::nondet30.1)

*** 31 file main.c line 30 function create_sll
(E) i#31 == 0

*** 32 file main.c line 30 function create_sll
(E) __CPROVER_deallocated#phi32 == ($guard#ls101 ? __CPROVER_deallocated#lb101 : __CPROVER_deallocated#3)
(E) __CPROVER_malloc_object#phi32 == ($guard#ls101 ? __CPROVER_malloc_object#lb101 : __CPROVER_malloc_object#5)
(E) __CPROVER_malloc_size#phi32 == ($guard#ls101 ? __CPROVER_malloc_size#lb101 : __CPROVER_malloc_size#6)
(E) __CPROVER_malloc_is_new_array#phi32 == ($guard#ls101 ? __CPROVER_malloc_is_new_array#lb101 : __CPROVER_malloc_is_new_array#4)
(E) __CPROVER_memory_leak#phi32 == ($guard#ls101 ? __CPROVER_memory_leak#lb101 : __CPROVER_memory_leak#7)
(E) i#phi32 == ($guard#ls101 ? i#lb101 : i#31)
(E) p2#phi32 == ($guard#ls101 ? p2#lb101 : p2#28)
(E) dynamic_object$0.next#phi32 == ($guard#ls101 ? dynamic_object$0.next#lb101 : dynamic_object$0.next)
(E) $cond#32 == i#phi32 >= 2
(E) $guard#32 == $guard#0

*** 33 file main.c line 32 function create_sll
(E) $guard#33 == (!$cond#32 && $guard#32)

*** 35 file main.c line 32 function create_sll
(E) ppnode#35 == nondet_symbol(ssa::nondet35.1)

*** 36 file main.c line 32 function create_sll
(E) ppnode#36 == pp2#27

*** 38 file main.c line 21 function chain_node
(E) node#38 == nondet_symbol(ssa::nondet38.1)

*** 41 file main.c line 11 function alloc_node
(E) ptr#41 == nondet_symbol(ssa::nondet41.1)

*** 43 file main.c line 11 function alloc_node
(E) return_value_malloc$1#43 == nondet_symbol(ssa::nondet43.1)

*** 46 file main.c line 11 function alloc_node
(E) malloc_size#46 == nondet_symbol(ssa::nondet46.1)

*** 47 file main.c line 11 function alloc_node
(E) malloc_size#47 == sizeof(struct node) /*8ul*/ 

*** 50 file main.c line 11 function alloc_node
(E) malloc_res#50 == nondet_symbol(ssa::nondet50.1)

*** 52 file main.c line 11 function alloc_node
(E) malloc_value$1#52 == nondet_symbol(ssa::nondet52.1)

*** 53 file main.c line 11 function alloc_node
(E) malloc_value$1#53 == (void *)&dynamic_object$0

*** 54 file main.c line 11 function alloc_node
(E) malloc_res#54 == malloc_value$1#53

*** 56 file main.c line 11 function alloc_node
(E) __CPROVER_deallocated#56 == (malloc_res#54 == __CPROVER_deallocated#phi32 ? NULL : __CPROVER_deallocated#phi32)

*** 58 file main.c line 11 function alloc_node
(E) record_malloc#58 == nondet_symbol(ssa::nondet58.1)

*** 59 file main.c line 11 function alloc_node
(E) __CPROVER_malloc_object#59 == (record_malloc#58 ? malloc_res#54 : __CPROVER_malloc_object#phi32)

*** 60 file main.c line 11 function alloc_node
(E) __CPROVER_malloc_size#60 == (record_malloc#58 ? malloc_size#47 : __CPROVER_malloc_size#phi32)

*** 61 file main.c line 11 function alloc_node
(E) __CPROVER_malloc_is_new_array#61 == (!record_malloc#58 && __CPROVER_malloc_is_new_array#phi32)

*** 63 file main.c line 11 function alloc_node
(E) record_may_leak#63 == nondet_symbol(ssa::nondet63.1)

*** 64 file main.c line 11 function alloc_node
(E) __CPROVER_memory_leak#64 == (record_may_leak#63 ? malloc_res#54 : __CPROVER_memory_leak#phi32)

*** 65 file main.c line 11 function alloc_node
(E) malloc#return_value#65 == malloc_res#54

*** 70 file main.c line 11 function alloc_node
(E) $cond#70 == TRUE

*** 71 file main.c line 11 function alloc_node
(E) $guard#71 == FALSE

*** 75 file main.c line 11 function alloc_node
(E) $guard#75 == ($cond#70 && $guard#33 || $guard#71)

*** 77 file main.c line 11 function alloc_node
(E) return_value_malloc$1#77 == malloc#return_value#65

*** 79 file main.c line 11 function alloc_node
(E) ptr#79 == (struct node *)return_value_malloc$1#77

*** 81 file main.c line 12 function alloc_node
(E) $cond#81 == !(ptr#79 == ((struct node *)NULL))

*** 82 file main.c line 13 function alloc_node
(E) $guard#82 == (!$cond#81 && $guard#75)

*** 83 file <builtin-library-abort> line 6 function abort
(E) $cond#83 == FALSE

*** 84 file <builtin-library-abort> line 7 function abort
(E) $guard#84 == ($cond#83 && $guard#82)

*** 85 file main.c line 15 function alloc_node
(E) dynamic_object$0.next#85 == ((struct node *)NULL)
(E) $guard#85 == ($cond#81 && $guard#75 || $guard#84)

*** 86 file main.c line 16 function alloc_node
(E) alloc_node#return_value#86 == ptr#79

*** 89 file main.c line 16 function alloc_node
(E) $cond#89 == TRUE

*** 90 file main.c line 17 function alloc_node
(E) $guard#90 == FALSE

*** 92 file main.c line 17 function alloc_node
(E) $guard#92 == ($cond#89 && $guard#85 || $guard#90)

*** 93 file main.c line 21 function chain_node
(E) node#93 == alloc_node#return_value#86

*** 95 file main.c line 22 function chain_node
(E) dynamic_object$0.next#95 == (ppnode#36 == &p2 ? p2#phi32 : deref#95)

*** 96 file main.c line 23 function chain_node
(E) p2#96 == node#93

*** 100 file main.c line 30 function create_sll
(E) i#100 == 1 + i#phi32

*** 101 file main.c line 30 function create_sll
(E) $cond#101 == TRUE
loop back to location 32

*** 102 file main.c line 33 function create_sll
(E) $guard#102 == ($cond#32 && $guard#32)

*** 103 file main.c line 35 function create_sll
(E) p1#103 == (pp2#27 == &p2 ? p2#phi32 : deref#103)

*** 105 file main.c line 37 function create_sll
(E) i#105 == nondet_symbol(ssa::nondet105.1)

*** 106 file main.c line 37 function create_sll
(E) i#106 == 0

*** 107 file main.c line 37 function create_sll
(E) __CPROVER_deallocated#phi107 == ($guard#ls176 ? __CPROVER_deallocated#lb176 : __CPROVER_deallocated#phi32)
(E) __CPROVER_malloc_object#phi107 == ($guard#ls176 ? __CPROVER_malloc_object#lb176 : __CPROVER_malloc_object#phi32)
(E) __CPROVER_malloc_size#phi107 == ($guard#ls176 ? __CPROVER_malloc_size#lb176 : __CPROVER_malloc_size#phi32)
(E) __CPROVER_malloc_is_new_array#phi107 == ($guard#ls176 ? __CPROVER_malloc_is_new_array#lb176 : __CPROVER_malloc_is_new_array#phi32)
(E) __CPROVER_memory_leak#phi107 == ($guard#ls176 ? __CPROVER_memory_leak#lb176 : __CPROVER_memory_leak#phi32)
(E) i#phi107 == ($guard#ls176 ? i#lb176 : i#106)
(E) p1#phi107 == ($guard#ls176 ? p1#lb176 : p1#103)
(E) dynamic_object$1.next#phi107 == ($guard#ls176 ? dynamic_object$1.next#lb176 : dynamic_object$1.next)
(E) $cond#107 == i#phi107 >= 2
(E) $guard#107 == $guard#102

*** 108 file main.c line 39 function create_sll
(E) $guard#108 == (!$cond#107 && $guard#107)

*** 110 file main.c line 39 function create_sll
(E) ppnode#110 == nondet_symbol(ssa::nondet110.1)

*** 111 file main.c line 39 function create_sll
(E) ppnode#111 == pp1#24

*** 113 file main.c line 21 function chain_node
(E) node#113 == nondet_symbol(ssa::nondet113.1)

*** 116 file main.c line 11 function alloc_node
(E) ptr#116 == nondet_symbol(ssa::nondet116.1)

*** 118 file main.c line 11 function alloc_node
(E) return_value_malloc$1#118 == nondet_symbol(ssa::nondet118.1)

*** 121 file main.c line 11 function alloc_node
(E) malloc_size#121 == nondet_symbol(ssa::nondet121.1)

*** 122 file main.c line 11 function alloc_node
(E) malloc_size#122 == sizeof(struct node) /*8ul*/ 

*** 125 file main.c line 11 function alloc_node
(E) malloc_res#125 == nondet_symbol(ssa::nondet125.1)

*** 127 file main.c line 11 function alloc_node
(E) malloc_value$1#127 == nondet_symbol(ssa::nondet127.1)

*** 128 file main.c line 11 function alloc_node
(E) malloc_value$1#128 == (void *)&dynamic_object$1

*** 129 file main.c line 11 function alloc_node
(E) malloc_res#129 == malloc_value$1#128

*** 131 file main.c line 11 function alloc_node
(E) __CPROVER_deallocated#131 == (malloc_res#129 == __CPROVER_deallocated#phi107 ? NULL : __CPROVER_deallocated#phi107)

*** 133 file main.c line 11 function alloc_node
(E) record_malloc#133 == nondet_symbol(ssa::nondet133.1)

*** 134 file main.c line 11 function alloc_node
(E) __CPROVER_malloc_object#134 == (record_malloc#133 ? malloc_res#129 : __CPROVER_malloc_object#phi107)

*** 135 file main.c line 11 function alloc_node
(E) __CPROVER_malloc_size#135 == (record_malloc#133 ? malloc_size#122 : __CPROVER_malloc_size#phi107)

*** 136 file main.c line 11 function alloc_node
(E) __CPROVER_malloc_is_new_array#136 == (!record_malloc#133 && __CPROVER_malloc_is_new_array#phi107)

*** 138 file main.c line 11 function alloc_node
(E) record_may_leak#138 == nondet_symbol(ssa::nondet138.1)

*** 139 file main.c line 11 function alloc_node
(E) __CPROVER_memory_leak#139 == (record_may_leak#138 ? malloc_res#129 : __CPROVER_memory_leak#phi107)

*** 140 file main.c line 11 function alloc_node
(E) malloc#return_value#140 == malloc_res#129

*** 145 file main.c line 11 function alloc_node
(E) $cond#145 == TRUE

*** 146 file main.c line 11 function alloc_node
(E) $guard#146 == FALSE

*** 150 file main.c line 11 function alloc_node
(E) $guard#150 == ($cond#145 && $guard#108 || $guard#146)

*** 152 file main.c line 11 function alloc_node
(E) return_value_malloc$1#152 == malloc#return_value#140

*** 154 file main.c line 11 function alloc_node
(E) ptr#154 == (struct node *)return_value_malloc$1#152

*** 156 file main.c line 12 function alloc_node
(E) $cond#156 == !(ptr#154 == ((struct node *)NULL))

*** 157 file main.c line 13 function alloc_node
(E) $guard#157 == (!$cond#156 && $guard#150)

*** 158 file <builtin-library-abort> line 6 function abort
(E) $cond#158 == FALSE

*** 159 file <builtin-library-abort> line 7 function abort
(E) $guard#159 == ($cond#158 && $guard#157)

*** 160 file main.c line 15 function alloc_node
(E) dynamic_object$1.next#160 == ((struct node *)NULL)
(E) $guard#160 == ($cond#156 && $guard#150 || $guard#159)

*** 161 file main.c line 16 function alloc_node
(E) alloc_node#return_value#161 == ptr#154

*** 164 file main.c line 16 function alloc_node
(E) $cond#164 == TRUE

*** 165 file main.c line 17 function alloc_node
(E) $guard#165 == FALSE

*** 167 file main.c line 17 function alloc_node
(E) $guard#167 == ($cond#164 && $guard#160 || $guard#165)

*** 168 file main.c line 21 function chain_node
(E) node#168 == alloc_node#return_value#161

*** 170 file main.c line 22 function chain_node
(E) dynamic_object$1.next#170 == (ppnode#111 == &p1 ? p1#phi107 : deref#170)

*** 171 file main.c line 23 function chain_node
(E) p1#171 == node#168

*** 175 file main.c line 37 function create_sll
(E) i#175 == 1 + i#phi107

*** 176 file main.c line 37 function create_sll
(E) $cond#176 == TRUE
loop back to location 107

*** 177 file main.c line 40 function create_sll
(E) $guard#177 == ($cond#107 && $guard#107)

*** 179 file main.c line 42 function create_sll
(E) list#179 == nondet_symbol(ssa::nondet179.1)

*** 180 file main.c line 42 function create_sll
(E) list#180 == (pp1#24 == &p1 ? p1#phi107 : deref#180)

*** 182 file main.c line 44 function create_sll
(E) i#182 == nondet_symbol(ssa::nondet182.1)

*** 183 file main.c line 44 function create_sll
(E) i#183 == 0

*** 184 file main.c line 44 function create_sll
(E) __CPROVER_deallocated#phi184 == ($guard#ls253 ? __CPROVER_deallocated#lb253 : __CPROVER_deallocated#phi107)
(E) __CPROVER_malloc_object#phi184 == ($guard#ls253 ? __CPROVER_malloc_object#lb253 : __CPROVER_malloc_object#phi107)
(E) __CPROVER_malloc_size#phi184 == ($guard#ls253 ? __CPROVER_malloc_size#lb253 : __CPROVER_malloc_size#phi107)
(E) __CPROVER_malloc_is_new_array#phi184 == ($guard#ls253 ? __CPROVER_malloc_is_new_array#lb253 : __CPROVER_malloc_is_new_array#phi107)
(E) __CPROVER_memory_leak#phi184 == ($guard#ls253 ? __CPROVER_memory_leak#lb253 : __CPROVER_memory_leak#phi107)
(E) list#phi184 == ($guard#ls253 ? list#lb253 : list#180)
(E) i#phi184 == ($guard#ls253 ? i#lb253 : i#183)
(E) dynamic_object$2.next#phi184 == ($guard#ls253 ? dynamic_object$2.next#lb253 : dynamic_object$2.next)
(E) $cond#184 == i#phi184 >= 2
(E) $guard#184 == $guard#177

*** 185 file main.c line 46 function create_sll
(E) $guard#185 == (!$cond#184 && $guard#184)

*** 187 file main.c line 46 function create_sll
(E) ppnode#187 == nondet_symbol(ssa::nondet187.1)

*** 188 file main.c line 46 function create_sll
(E) ppnode#188 == &list

*** 190 file main.c line 21 function chain_node
(E) node#190 == nondet_symbol(ssa::nondet190.1)

*** 193 file main.c line 11 function alloc_node
(E) ptr#193 == nondet_symbol(ssa::nondet193.1)

*** 195 file main.c line 11 function alloc_node
(E) return_value_malloc$1#195 == nondet_symbol(ssa::nondet195.1)

*** 198 file main.c line 11 function alloc_node
(E) malloc_size#198 == nondet_symbol(ssa::nondet198.1)

*** 199 file main.c line 11 function alloc_node
(E) malloc_size#199 == sizeof(struct node) /*8ul*/ 

*** 202 file main.c line 11 function alloc_node
(E) malloc_res#202 == nondet_symbol(ssa::nondet202.1)

*** 204 file main.c line 11 function alloc_node
(E) malloc_value$1#204 == nondet_symbol(ssa::nondet204.1)

*** 205 file main.c line 11 function alloc_node
(E) malloc_value$1#205 == (void *)&dynamic_object$2

*** 206 file main.c line 11 function alloc_node
(E) malloc_res#206 == malloc_value$1#205

*** 208 file main.c line 11 function alloc_node
(E) __CPROVER_deallocated#208 == (malloc_res#206 == __CPROVER_deallocated#phi184 ? NULL : __CPROVER_deallocated#phi184)

*** 210 file main.c line 11 function alloc_node
(E) record_malloc#210 == nondet_symbol(ssa::nondet210.1)

*** 211 file main.c line 11 function alloc_node
(E) __CPROVER_malloc_object#211 == (record_malloc#210 ? malloc_res#206 : __CPROVER_malloc_object#phi184)

*** 212 file main.c line 11 function alloc_node
(E) __CPROVER_malloc_size#212 == (record_malloc#210 ? malloc_size#199 : __CPROVER_malloc_size#phi184)

*** 213 file main.c line 11 function alloc_node
(E) __CPROVER_malloc_is_new_array#213 == (!record_malloc#210 && __CPROVER_malloc_is_new_array#phi184)

*** 215 file main.c line 11 function alloc_node
(E) record_may_leak#215 == nondet_symbol(ssa::nondet215.1)

*** 216 file main.c line 11 function alloc_node
(E) __CPROVER_memory_leak#216 == (record_may_leak#215 ? malloc_res#206 : __CPROVER_memory_leak#phi184)

*** 217 file main.c line 11 function alloc_node
(E) malloc#return_value#217 == malloc_res#206

*** 222 file main.c line 11 function alloc_node
(E) $cond#222 == TRUE

*** 223 file main.c line 11 function alloc_node
(E) $guard#223 == FALSE

*** 227 file main.c line 11 function alloc_node
(E) $guard#227 == ($cond#222 && $guard#185 || $guard#223)

*** 229 file main.c line 11 function alloc_node
(E) return_value_malloc$1#229 == malloc#return_value#217

*** 231 file main.c line 11 function alloc_node
(E) ptr#231 == (struct node *)return_value_malloc$1#229

*** 233 file main.c line 12 function alloc_node
(E) $cond#233 == !(ptr#231 == ((struct node *)NULL))

*** 234 file main.c line 13 function alloc_node
(E) $guard#234 == (!$cond#233 && $guard#227)

*** 235 file <builtin-library-abort> line 6 function abort
(E) $cond#235 == FALSE

*** 236 file <builtin-library-abort> line 7 function abort
(E) $guard#236 == ($cond#235 && $guard#234)

*** 237 file main.c line 15 function alloc_node
(E) dynamic_object$2.next#237 == ((struct node *)NULL)
(E) $guard#237 == ($cond#233 && $guard#227 || $guard#236)

*** 238 file main.c line 16 function alloc_node
(E) alloc_node#return_value#238 == ptr#231

*** 241 file main.c line 16 function alloc_node
(E) $cond#241 == TRUE

*** 242 file main.c line 17 function alloc_node
(E) $guard#242 == FALSE

*** 244 file main.c line 17 function alloc_node
(E) $guard#244 == ($cond#241 && $guard#237 || $guard#242)

*** 245 file main.c line 21 function chain_node
(E) node#245 == alloc_node#return_value#238

*** 247 file main.c line 22 function chain_node
(E) dynamic_object$2.next#247 == (ppnode#188 == &list ? list#phi184 : deref#247)

*** 248 file main.c line 23 function chain_node
(E) list#248 == node#245

*** 252 file main.c line 44 function create_sll
(E) i#252 == 1 + i#phi184

*** 253 file main.c line 44 function create_sll
(E) $cond#253 == TRUE
loop back to location 184

*** 254 file main.c line 47 function create_sll
(E) $guard#254 == ($cond#184 && $guard#184)

*** 255 file main.c line 49 function create_sll
(E) create_sll#return_value#255 == list#phi184

*** 257 file main.c line 49 function create_sll
(E) $cond#257 == TRUE

*** 258 file main.c line 50 function create_sll
(E) $guard#258 == FALSE

*** 259 file main.c line 50 function create_sll
(E) $guard#259 == ($cond#257 && $guard#254 || $guard#258)

*** 262 file main.c line 64 function main
(E) list#262 == create_sll#return_value#255

*** 266 file main.c line 65 function main
(E) beg#266 == nondet_symbol(ssa::nondet266.1)

*** 267 file main.c line 65 function main
(E) beg#267 == list#262

*** 269 file main.c line 65 function main
(E) end#269 == nondet_symbol(ssa::nondet269.1)

*** 270 file main.c line 65 function main
(E) end#270 == p1#phi107

*** 271 file main.c line 53 function check_seq_next
(A) !(beg#267 == ((struct node *)NULL)) || !$guard#259

*** 272 file main.c line 54 function check_seq_next
(A) !(end#270 == ((struct node *)NULL)) || !$guard#259

*** 273 file main.c line 56 function check_seq_next
(E) beg#273 == (beg#267 == &dynamic_object$2 ? dynamic_object$2.next#phi184 : (beg#267 == &dynamic_object$1 ? dynamic_object$1.next#phi107 : (beg#267 == &dynamic_object$0 ? dynamic_object$0.next#phi32 : deref#273.next)))

*** 274 file main.c line 56 function check_seq_next
(E) beg#phi274 == ($guard#ls277 ? beg#lb277 : beg#273)
(E) $cond#274 == (end#270 == beg#phi274)
(E) $guard#274 == $guard#259

*** 275 file main.c line 57 function check_seq_next
(E) $guard#275 == (!$cond#274 && $guard#274)
(A) !(beg#phi274 == ((struct node *)NULL)) || !$guard#275

*** 276 file main.c line 56 function check_seq_next
(E) beg#276 == (beg#phi274 == &dynamic_object$2 ? dynamic_object$2.next#phi184 : (beg#phi274 == &dynamic_object$1 ? dynamic_object$1.next#phi107 : (beg#phi274 == &dynamic_object$0 ? dynamic_object$0.next#phi32 : deref#276.next)))

*** 277 file main.c line 56 function check_seq_next
(E) $cond#277 == TRUE
loop back to location 274

*** 278 file main.c line 58 function check_seq_next
(E) $guard#278 == ($cond#274 && $guard#274)

*** 283 file main.c line 66 function main
(E) beg#283 == nondet_symbol(ssa::nondet283.1)

*** 284 file main.c line 66 function main
(E) beg#284 == p1#phi107

*** 286 file main.c line 66 function main
(E) end#286 == nondet_symbol(ssa::nondet286.1)

*** 287 file main.c line 66 function main
(E) end#287 == p2#phi32

*** 288 file main.c line 53 function check_seq_next
(A) !(beg#284 == ((struct node *)NULL)) || !$guard#278

*** 289 file main.c line 54 function check_seq_next
(A) !(end#287 == ((struct node *)NULL)) || !$guard#278

*** 290 file main.c line 56 function check_seq_next
(E) beg#290 == (beg#284 == &dynamic_object$1 ? dynamic_object$1.next#phi107 : (beg#284 == &dynamic_object$0 ? dynamic_object$0.next#phi32 : deref#290.next))

*** 291 file main.c line 56 function check_seq_next
(E) beg#phi291 == ($guard#ls294 ? beg#lb294 : beg#290)
(E) $cond#291 == (end#287 == beg#phi291)
(E) $guard#291 == $guard#278

*** 292 file main.c line 57 function check_seq_next
(E) $guard#292 == (!$cond#291 && $guard#291)
(A) !(beg#phi291 == ((struct node *)NULL)) || !$guard#292

*** 293 file main.c line 56 function check_seq_next
(E) beg#293 == (beg#phi291 == &dynamic_object$1 ? dynamic_object$1.next#phi107 : (beg#phi291 == &dynamic_object$0 ? dynamic_object$0.next#phi32 : deref#293.next))

*** 294 file main.c line 56 function check_seq_next
(E) $cond#294 == TRUE
loop back to location 291

*** 295 file main.c line 58 function check_seq_next
(E) $guard#295 == ($cond#291 && $guard#291)

(enable) TRUE


Callee summaries:
Callee bindings:

Loops not fully unwound
Running refinement loop with MiniSAT 2.2.1 with simplifier
** 0 of 6 failed (1 iterations)
** statistics: 
  number of solver instances: 1
  number of solver calls: 14
  number of summaries used: 0

[check_seq_next.assertion.1] assertion beg != (struct node *)(void *)0: OK
[check_seq_next.assertion.2] assertion end != (struct node *)(void *)0: OK
[check_seq_next.assertion.3] assertion beg != (struct node *)(void *)0: OK
[check_seq_next.assertion.4] assertion beg != (struct node *)(void *)0: OK
[check_seq_next.assertion.5] assertion end != (struct node *)(void *)0: OK
[check_seq_next.assertion.6] assertion beg != (struct node *)(void *)0: OK

** 0 of 6 unknown
** 0 of 6 failed
VERIFICATION SUCCESSFUL
EXIT=0
SIGNAL=0
